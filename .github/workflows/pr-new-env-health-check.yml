name: PR New Environment

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
    paths:
      - 'src/envs/**'

permissions:
  contents: read
  pull-requests: read

jobs:
  detect-new-envs:
    name: Detect Newly Added Environments
    runs-on: ubuntu-latest
    outputs:
      has_new_envs: ${{ steps.detect.outputs.has_new_envs }}
      new_envs: ${{ steps.detect.outputs.new_envs }}
      new_envs_json: ${{ steps.detect.outputs.new_envs_json }}
    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          path: base
          fetch-depth: 0
          persist-credentials: false

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.ref }}
          path: pr
          fetch-depth: 0
          persist-credentials: false

      - name: Determine new environment directories
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -d base/src/envs ]; then
            echo "Base repository missing src/envs directory."
            echo "has_new_envs=false" >> "$GITHUB_OUTPUT"
            echo "new_envs=" >> "$GITHUB_OUTPUT"
            echo "new_envs_json=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ ! -d pr/src/envs ]; then
            echo "PR repository missing src/envs directory."
            echo "has_new_envs=false" >> "$GITHUB_OUTPUT"
            echo "new_envs=" >> "$GITHUB_OUTPUT"
            echo "new_envs_json=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          mapfile -t BASE_ENVS < <(cd base/src/envs && find . -maxdepth 1 -mindepth 1 -type d | sed 's|^\./||' | sort)
          mapfile -t PR_ENVS < <(cd pr/src/envs && find . -maxdepth 1 -mindepth 1 -type d | sed 's|^\./||' | sort)

          declare -A BASE_SET=()
          for env in "${BASE_ENVS[@]}"; do
            BASE_SET["$env"]=1
          done

          NEW_ENV_ARRAY=()
          for env in "${PR_ENVS[@]}"; do
            if [ -z "${BASE_SET[$env]:-}" ]; then
              NEW_ENV_ARRAY+=("$env")
            fi
          done

          if [ ${#NEW_ENV_ARRAY[@]} -eq 0 ]; then
            echo "No new environment directories detected."
            echo "has_new_envs=false" >> "$GITHUB_OUTPUT"
            echo "new_envs=" >> "$GITHUB_OUTPUT"
            echo "new_envs_json=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          printf 'Detected new environments: %s\n' "$(printf '%s ' "${NEW_ENV_ARRAY[@]}")"

          NEW_ENVS_COMMA=$(printf '%s\n' "${NEW_ENV_ARRAY[@]}" | paste -sd, -)
          NEW_ENVS_JSON=$(printf '%s\n' "${NEW_ENV_ARRAY[@]}" | python -c 'import json,sys; print(json.dumps([line.strip() for line in sys.stdin if line.strip()]))')

          echo "has_new_envs=true" >> "$GITHUB_OUTPUT"
          echo "new_envs=${NEW_ENVS_COMMA}" >> "$GITHUB_OUTPUT"
          echo "new_envs_json=${NEW_ENVS_JSON}" >> "$GITHUB_OUTPUT"

  deploy-and-health-check:
    name: Deploy and Validate New Environments
    needs: detect-new-envs
    if: needs.detect-new-envs.outputs.has_new_envs == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJSON(needs.detect-new-envs.outputs.new_envs_json) }}
    env:
      HF_TOKEN: ${{ secrets.HF_PR_TOKEN }}
      HF_NAMESPACE: ${{ vars.HF_PR_NAMESPACE }}
      SPACE_SUFFIX: -pr-${{ github.event.number }}
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0
          persist-credentials: false

      - name: Default Hugging Face namespace
        if: env.HF_NAMESPACE == ''
        shell: bash
        run: echo "HF_NAMESPACE=openenv-testing" >> "$GITHUB_ENV"

      - name: Verify Hugging Face token
        shell: bash
        run: |
          if [ -z "${HF_TOKEN:-}" ]; then
            echo "HF_TOKEN secret is required for deployment." >&2
            exit 1
          fi

      - name: Install Hugging Face CLI
        shell: bash
        run: |
          curl -LsSf https://hf.co/cli/install.sh | bash
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Deploy environment to Hugging Face
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/deploy_to_hf.sh
          ./scripts/deploy_to_hf.sh --env "${{ matrix.environment }}" --space-suffix "${SPACE_SUFFIX}" --private

      - name: Wait for deployment to stabilize
        shell: bash
        run: sleep 300

      - name: Perform environment health check
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${HF_NAMESPACE:-}" ]; then
            echo "HF_NAMESPACE is not configured; unable to compute health check URL." >&2
            exit 1
          fi

          namespace_slug=$(echo "${HF_NAMESPACE}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
          space_name="${{ matrix.environment }}${SPACE_SUFFIX}"
          space_slug=$(echo "${space_name}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
          health_url="https://${namespace_slug}-${space_slug}.hf.space/health"

          echo "Checking health for ${space_name} at ${health_url}"

          success=0
          for attempt in {1..5}; do
            status=$(curl -sS -o response.json -w "%{http_code}" "$health_url" || echo "000")
            if [ "$status" = "200" ]; then
              echo "Health check passed for ${space_name}"
              cat response.json
              success=1
              break
            fi
            echo "Attempt ${attempt} returned status ${status}. Retrying in 30 seconds..."
            sleep 30
          done

          if [ $success -ne 1 ]; then
            echo "Health check failed for ${space_name}" >&2
            if [ -f response.json ]; then
              echo "Last response payload:"
              cat response.json
            fi
            exit 1
          fi