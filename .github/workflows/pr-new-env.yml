name: PR New Environment

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
    paths:
      - 'src/envs/**'

permissions:
  contents: read
  pull-requests: write

jobs:
  detect-new-envs:
    name: Detect Newly Added Environments
    runs-on: ubuntu-latest
    outputs:
      has_new_envs: ${{ steps.detect.outputs.has_new_envs }}
      new_envs: ${{ steps.detect.outputs.new_envs }}
      new_envs_json: ${{ steps.detect.outputs.new_envs_json }}
    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          path: base
          fetch-depth: 0
          persist-credentials: false

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.ref }}
          path: pr
          fetch-depth: 0
          persist-credentials: false

      - name: Determine new environment directories
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -d base/src/envs ]; then
            echo "Base repository missing src/envs directory."
            echo "has_new_envs=false" >> "$GITHUB_OUTPUT"
            echo "new_envs=" >> "$GITHUB_OUTPUT"
            echo "new_envs_json=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ ! -d pr/src/envs ]; then
            echo "PR repository missing src/envs directory."
            echo "has_new_envs=false" >> "$GITHUB_OUTPUT"
            echo "new_envs=" >> "$GITHUB_OUTPUT"
            echo "new_envs_json=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          mapfile -t BASE_ENVS < <(cd base/src/envs && find . -maxdepth 1 -mindepth 1 -type d | sed 's|^\./||' | sort)
          mapfile -t PR_ENVS < <(cd pr/src/envs && find . -maxdepth 1 -mindepth 1 -type d | sed 's|^\./||' | sort)

          declare -A BASE_SET=()
          for env in "${BASE_ENVS[@]}"; do
            BASE_SET["$env"]=1
          done

          NEW_ENV_ARRAY=()
          for env in "${PR_ENVS[@]}"; do
            if [ -z "${BASE_SET[$env]:-}" ]; then
              NEW_ENV_ARRAY+=("$env")
            fi
          done

          if [ ${#NEW_ENV_ARRAY[@]} -eq 0 ]; then
            echo "No new environment directories detected."
            echo "has_new_envs=false" >> "$GITHUB_OUTPUT"
            echo "new_envs=" >> "$GITHUB_OUTPUT"
            echo "new_envs_json=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          printf 'Detected new environments: %s\n' "$(printf '%s ' "${NEW_ENV_ARRAY[@]}")"

          NEW_ENVS_COMMA=$(printf '%s\n' "${NEW_ENV_ARRAY[@]}" | paste -sd, -)
          NEW_ENVS_JSON=$(printf '%s\n' "${NEW_ENV_ARRAY[@]}" | python -c 'import json,sys; print(json.dumps([line.strip() for line in sys.stdin if line.strip()]))')

          echo "has_new_envs=true" >> "$GITHUB_OUTPUT"
          echo "new_envs=${NEW_ENVS_COMMA}" >> "$GITHUB_OUTPUT"
          echo "new_envs_json=${NEW_ENVS_JSON}" >> "$GITHUB_OUTPUT"

  deploy-and-health-check:
    name: Deploy and Validate New Environments
    needs: detect-new-envs
    if: needs.detect-new-envs.outputs.has_new_envs == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJSON(needs.detect-new-envs.outputs.new_envs_json) }}
    env:
      HF_TOKEN: ${{ secrets.HF_PR_TOKEN }}
      HF_NAMESPACE: ${{ vars.HF_PR_NAMESPACE }}
      SPACE_SUFFIX: -pr-${{ github.event.number }}
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0
          persist-credentials: false

      - name: Default Hugging Face namespace
        if: env.HF_NAMESPACE == ''
        shell: bash
        run: echo "HF_NAMESPACE=openenv-testing" >> "$GITHUB_ENV"

      - name: Verify Hugging Face token
        shell: bash
        run: |
          if [ -z "${HF_TOKEN:-}" ]; then
            echo "HF_TOKEN secret is required for deployment." >&2
            exit 1
          fi

      - name: Install Hugging Face CLI
        shell: bash
        run: |
          curl -LsSf https://hf.co/cli/install.sh | bash
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Deploy environment to Hugging Face
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/deploy_to_hf.sh
          ./scripts/deploy_to_hf.sh --env "${{ matrix.environment }}" --space-suffix "${SPACE_SUFFIX}" --hub-tag "openenv-pr"

      - name: Wait for deployment to stabilize
        shell: bash
        run: sleep 180

      - name: Compute Space URLs
        id: urls
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${HF_NAMESPACE:-}" ]; then
            echo "HF_NAMESPACE is not configured; unable to compute space URLs." >&2
            exit 1
          fi

          namespace_slug=$(echo "${HF_NAMESPACE}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
          space_name="${{ matrix.environment }}${SPACE_SUFFIX}"
          space_slug=$(echo "${space_name}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
          health_url="https://${namespace_slug}-${space_slug}.hf.space/health"
          live_url="https://${namespace_slug}-${space_slug}.hf.space"
          space_repo_url="https://huggingface.co/spaces/${HF_NAMESPACE}/${space_name}"

          echo "namespace_slug=${namespace_slug}" >> "$GITHUB_OUTPUT"
          echo "space_name=${space_name}" >> "$GITHUB_OUTPUT"
          echo "space_slug=${space_slug}" >> "$GITHUB_OUTPUT"
          echo "health_url=${health_url}" >> "$GITHUB_OUTPUT"
          echo "live_url=${live_url}" >> "$GITHUB_OUTPUT"
          echo "space_repo_url=${space_repo_url}" >> "$GITHUB_OUTPUT"

      - name: Perform environment health check
        id: health_check
        continue-on-error: true
        shell: bash
        env:
          HEALTH_URL: ${{ steps.urls.outputs.health_url }}
          SPACE_NAME: ${{ steps.urls.outputs.space_name }}
        run: |
          set -euo pipefail

          if [ -z "${HEALTH_URL:-}" ]; then
            echo "HEALTH_URL not provided; cannot perform health check." >&2
            exit 1
          fi

          echo "Checking health for ${SPACE_NAME} at ${HEALTH_URL}"

          success=0
          for attempt in {1..5}; do
            status=$(curl -sS -o response.json -w "%{http_code}" "$HEALTH_URL" || echo "000")
            if [ "$status" = "200" ]; then
              echo "Health check passed for ${SPACE_NAME}"
              cat response.json
              success=1
              break
            fi
            echo "Attempt ${attempt} returned status ${status}. Retrying in 30 seconds..."
            sleep 30
          done

          if [ $success -ne 1 ]; then
            echo "Health check failed for ${SPACE_NAME}" >&2
            if [ -f response.json ]; then
              echo "Last response payload:"
              cat response.json
            fi
            exit 1
          fi

      - name: Comment on PR with deployment status
        if: always()
        uses: actions/github-script@v7
        env:
          HEALTH_CONCLUSION: ${{ steps.health_check.conclusion }}
          SPACE_NAME: ${{ steps.urls.outputs.space_name }}
          LIVE_URL: ${{ steps.urls.outputs.live_url }}
          SPACE_REPO_URL: ${{ steps.urls.outputs.space_repo_url }}
          ENV_NAME: ${{ matrix.environment }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = process.env.HEALTH_CONCLUSION || 'failure';
            const spaceName = process.env.SPACE_NAME;
            const liveUrl = process.env.LIVE_URL;
            const repoUrl = process.env.SPACE_REPO_URL;
            const envName = process.env.ENV_NAME;

            const header = status === 'success'
              ? `✅ Deployment succeeded for \`${envName}\``
              : `⚠️ Deployment failed for \`${envName}\``;

            const summary = status === 'success'
              ? 'Nice work! Wait for a code review and we\'re ready to go.'
              : 'Please resolve your environment.';

            const body = [
              header,
              '',
              `- Space repo: [${repoUrl}](${repoUrl})`,
              `- Live URL: [${liveUrl}](${liveUrl})`,
              '',
              summary,
              '',
              'You can iterate locally or validate fixes by running `scripts/deploy_to_hf.sh --env "' + envName + '"`.'
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body
            });

      - name: Fail job if health check failed
        if: steps.health_check.conclusion == 'failure'
        run: exit 1
