name: PR New Environment

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
    paths:
      - 'src/envs/**'

permissions:
  contents: read
  pull-requests: write

jobs:
  detect-new-envs:
    name: Detect Newly Added Environments
    runs-on: ubuntu-latest
    outputs:
      has_new_envs: ${{ steps.detect.outputs.has_new_envs }}
      new_envs: ${{ steps.detect.outputs.new_envs }}
      new_envs_json: ${{ steps.detect.outputs.new_envs_json }}
    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          path: base
          fetch-depth: 0
          persist-credentials: false

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.ref }}
          path: pr
          fetch-depth: 0
          persist-credentials: false

      - name: Determine new environment directories
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -d base/src/envs ]; then
            echo "Base repository missing src/envs directory."
            echo "has_new_envs=false" >> "$GITHUB_OUTPUT"
            echo "new_envs=" >> "$GITHUB_OUTPUT"
            echo "new_envs_json=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ ! -d pr/src/envs ]; then
            echo "PR repository missing src/envs directory."
            echo "has_new_envs=false" >> "$GITHUB_OUTPUT"
            echo "new_envs=" >> "$GITHUB_OUTPUT"
            echo "new_envs_json=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          mapfile -t BASE_ENVS < <(cd base/src/envs && find . -maxdepth 1 -mindepth 1 -type d | sed 's|^\./||' | sort)
          mapfile -t PR_ENVS < <(cd pr/src/envs && find . -maxdepth 1 -mindepth 1 -type d | sed 's|^\./||' | sort)

          declare -A BASE_SET=()
          for env in "${BASE_ENVS[@]}"; do
            BASE_SET["$env"]=1
          done

          NEW_ENV_ARRAY=()
          for env in "${PR_ENVS[@]}"; do
            if [ -z "${BASE_SET[$env]:-}" ]; then
              NEW_ENV_ARRAY+=("$env")
            fi
          done

          if [ ${#NEW_ENV_ARRAY[@]} -eq 0 ]; then
            echo "No new environment directories detected."
            echo "has_new_envs=false" >> "$GITHUB_OUTPUT"
            echo "new_envs=" >> "$GITHUB_OUTPUT"
            echo "new_envs_json=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          printf 'Detected new environments: %s\n' "$(printf '%s ' "${NEW_ENV_ARRAY[@]}")"

          NEW_ENVS_COMMA=$(printf '%s\n' "${NEW_ENV_ARRAY[@]}" | paste -sd, -)
          NEW_ENVS_JSON=$(printf '%s\n' "${NEW_ENV_ARRAY[@]}" | python -c 'import json,sys; print(json.dumps([line.strip() for line in sys.stdin if line.strip()]))')

          echo "has_new_envs=true" >> "$GITHUB_OUTPUT"
          echo "new_envs=${NEW_ENVS_COMMA}" >> "$GITHUB_OUTPUT"
          echo "new_envs_json=${NEW_ENVS_JSON}" >> "$GITHUB_OUTPUT"

  deploy-and-health-check:
    name: Validate New Environments
    needs: detect-new-envs
    if: needs.detect-new-envs.outputs.has_new_envs == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJSON(needs.detect-new-envs.outputs.new_envs_json) }}
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0
          persist-credentials: false

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install OpenEnv package
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install .

      - name: Run openenv validate --verbose
        id: validate
        shell: bash
        run: |
          set -u -o pipefail
          env_dir="src/envs/${{ matrix.environment }}"

          if [ ! -d "$env_dir" ]; then
            echo "Environment directory not found: $env_dir" >&2
            echo "status=failure" >> "$GITHUB_OUTPUT"
            printf "details<<EOF\n%s\nEOF\n" "Environment directory not found" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          cd "$env_dir"
          echo "Running openenv validate --verbose in $(pwd)"

          output_file="$(mktemp)"
          if openenv validate --verbose | tee "$output_file"; then
            status="success"
            exit_code=0
          else
            status="failure"
            exit_code=$?
          fi

          log_contents="$(cat "$output_file")"
          rm -f "$output_file"

          echo "status=${status}" >> "$GITHUB_OUTPUT"
          printf "details<<EOF\n%s\nEOF\n" "$log_contents" >> "$GITHUB_OUTPUT"

          exit "$exit_code"

      - name: Comment on PR with deployment status
        if: always()
        uses: actions/github-script@v7
        env:
          VALIDATION_STATUS: ${{ steps.validate.outputs.status }}
          VALIDATION_LOG: ${{ steps.validate.outputs.details }}
          ENV_NAME: ${{ matrix.environment }}
          COMMENT_TAG: "<!-- openenv-pr-preview -->"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = (process.env.VALIDATION_STATUS || '').toLowerCase() === 'success' ? 'success' : 'failure';
            const envName = process.env.ENV_NAME;
            const marker = process.env.COMMENT_TAG;

            const header = status === 'success'
              ? `✅ Validation succeeded for \`${envName}\``
              : `⚠️ Validation failed for \`${envName}\``;

            const summary = status === 'success'
              ? 'Nice work! Validation passed. Re-run locally with:'
              : 'Validation reported issues. Review the log and re-run locally:';

            const envDir = 'src/envs/' + envName;
            const rawLog = process.env.VALIDATION_LOG || '';
            const trimmedLog = rawLog.trim();
            const maxLength = 6000;
            let displayLog = trimmedLog;
            if (displayLog.length > maxLength) {
              displayLog = displayLog.slice(0, maxLength) + '\n... (truncated)';
            }

            const bodyLines = [
              marker,
              '',
              header,
              '',
              '',
              summary,
              '',
              '- `openenv validate --verbose ' + envDir + '`',
              '',
              '```\n' + displayLog + '\n```',
              'You can deploy the environment to Hugging Face Spaces by running `openenv push`.'
            ];

            const {owner, repo} = context.repo;
            const issue_number = context.payload.pull_request.number;
            const serverUrl = process.env.GITHUB_SERVER_URL || 'https://github.com';
            const runUrl = `${serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`;

            if (status !== 'success') {
              bodyLines.push(`- Failed run: ${runUrl}`);
            } else {
              bodyLines.push(`- Success run: ${runUrl}`);
            }

            const bodyText = bodyLines.join('\n');

            const existing = await github.paginate(
              github.rest.issues.listComments,
              { owner, repo, issue_number, per_page: 100 },
              (response, done) => {
                const match = response.data.find(comment => comment.body && comment.body.includes(marker));
                if (match) {
                  done();
                  return [match];
                }
                return [];
              }
            );

            if (existing.length > 0) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing[0].id,
                body: bodyText,
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: bodyText,
              });
            }
